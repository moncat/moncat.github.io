(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{434:function(e,o,t){"use strict";t.r(o);var l=t(2),n=Object(l.a)({},(function(){var e=this,o=e._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[e._v("Executors 类提供了几种不同类型的线程池，每种线程池都有不同的特点和适用场景，下面是常见的几种线程池类型及其区别：")]),e._v(" "),o("ol",[o("li",[o("p",[o("code",[e._v("newFixedThreadPool(int nThreads)")]),e._v("：创建一个固定大小的线程池，该线程池中的线程数量是固定的。如果提交的任务数大于线程池中的线程数，那么多余的任务将被放入队列中等待执行。适用于需要控制并发线程数量的场景。")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("newCachedThreadPool()")]),e._v("：创建一个缓存线程池，该线程池的线程数量可以根据需要进行自动调整。当有新任务提交时，如果有空闲线程，则立即执行；如果没有空闲线程，则创建一个新线程执行任务。当线程在60秒内没有被使用时，它们将被终止并从线程池中移除。适用于需要灵活处理大量短期异步任务的场景。")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("newSingleThreadExecutor()")]),e._v("：创建一个单线程化的线程池，该线程池只有一个工作线程。所有提交的任务都将按顺序执行，保证不会有并发访问的问题。适用于需要顺序执行任务且保持顺序的场景。")])]),e._v(" "),o("li",[o("p",[o("code",[e._v("newScheduledThreadPool(int corePoolSize)")]),e._v("：创建一个固定大小的调度线程池，该线程池可以执行定时任务和延迟任务。适用于需要执行定时任务或延迟任务的场景。")])])]),e._v(" "),o("p",[e._v("这些线程池都是基于 "),o("code",[e._v("ThreadPoolExecutor")]),e._v(" 实现的，其中有关并发和线程管理的细节已经被封装，简化了线程池的使用。")]),e._v(" "),o("p",[e._v("在选择线程池类型时，你需要根据具体的业务需求来决定使用哪种线程池。考虑到不同线程池的特点和适用场景，选择合适的线程池类型可以提高应用程序的性能和效率。")])])}),[],!1,null,null,null);o.default=n.exports}}]);